# -*- coding: utf-8 -*-
"""k200154_DS_Lab6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K5HUKbBu_NHT8tdDsjRCUeWMq1uvRwGA
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import matplotlib.pyplot as plt
# %matplotlib inline

"""## Dataset 1 – USA Poverty Level Wages

Link: https://www.kaggle.com/datasets/asaniczka/poverty-level-wages-in-the-usa-dataset-1973-2022
"""

# Reading the data into a dataframe

df1 = pd.read_csv("../Lab 5/poverty_level_wages.csv")
df1

# Checking for NaN values

df1.isna().sum()

# Standardising the data

scaler = StandardScaler()
scaled_df1 = pd.DataFrame(scaler.fit_transform(df1))
scaled_df1

# Implementing KMeans

kmeans = KMeans(n_clusters = 3, init = 'random')
kmeans.fit(scaled_df1)

pred = kmeans.predict(scaled_df1)
pred

kmeans.cluster_centers_

kmeans.inertia_

kmeans.n_iter_

kmeans.labels_

# ELbow graph to determine ideal number of clusters

SSE = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters = k, init = 'random')
    kmeans.fit(scaled_df1)
    SSE.append(kmeans.inertia_)

plt.plot(range(1, 11), SSE)
plt.xlabel("Number of Clusters")
plt.ylabel("SSE")
plt.show()

"""The elbow is at 4; thus, the ideal number of clusters is 4."""

# determining the silhouette coefficient

kmeans = KMeans(n_clusters = 4, init = 'random')
kmeans.fit(scaled_df1)
pred = kmeans.predict(scaled_df1)

print("Silhouette coefficient with 4 clusters: ", silhouette_score(scaled_df1, pred))

"""Now, we repeat the experiment for KMeans++"""

# Implementing KMeans

kmeans = KMeans(n_clusters = 3, init = 'k-means++')
kmeans.fit(scaled_df1)

pred = kmeans.predict(scaled_df1)
pred

kmeans.cluster_centers_

kmeans.inertia_

kmeans.n_iter_

kmeans.labels_

# ELbow graph to determine ideal number of clusters

SSE = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters = k, init = 'k-means++')
    kmeans.fit(scaled_df1)
    SSE.append(kmeans.inertia_)

plt.plot(range(1, 11), SSE)
plt.xlabel("Number of Clusters")
plt.ylabel("SSE")
plt.show()

"""The elbow is at 4; thus, the ideal number of clusters is 4."""

# determining the silhouette coefficient

kmeans = KMeans(n_clusters = 4, init = 'k-means++')
kmeans.fit(scaled_df1)
pred = kmeans.predict(scaled_df1)

print("Silhouette coefficient with 4 clusters: ", silhouette_score(scaled_df1, pred))

"""## DataSet 2 – USA Unemployment

Link: https://www.kaggle.com/datasets/asaniczka/unemployment-rates-by-demographics-1978-2023
"""

# Reading the data into a dataframe

df2 = pd.read_csv("../Lab 5/unemployment.csv")
df2

# dropping non-numeric column

df2.drop(columns = ["date"], inplace = True)
df2

# Checking for NaN values

df2.isna().sum()

# Standardising the data

scaler = StandardScaler()
scaled_df2 = pd.DataFrame(scaler.fit_transform(df2))
scaled_df2

# Implementing KMeans

kmeans = KMeans(n_clusters = 3, init = 'random')
kmeans.fit(scaled_df2)

pred = kmeans.predict(scaled_df2)
pred

kmeans.cluster_centers_

kmeans.inertia_

kmeans.n_iter_

kmeans.labels_

# ELbow graph to determine ideal number of clusters

SSE = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters = k, init = 'random')
    kmeans.fit(scaled_df2)
    SSE.append(kmeans.inertia_)

plt.plot(range(1, 11), SSE)
plt.xlabel("Number of Clusters")
plt.ylabel("SSE")
plt.show()

"""The elbow is at 2; thus, the ideal number of clusters is 2."""

# determining the silhouette coefficient

kmeans = KMeans(n_clusters = 2, init = 'random')
kmeans.fit(scaled_df2)
pred = kmeans.predict(scaled_df2)

print("Silhouette coefficient with 2 clusters: ", silhouette_score(scaled_df2, pred))

"""Now, we repeat the experiment for KMeans++"""

# Implementing KMeans

kmeans = KMeans(n_clusters = 3, init = 'k-means++')
kmeans.fit(scaled_df2)

pred = kmeans.predict(scaled_df2)
pred

kmeans.cluster_centers_

kmeans.inertia_

kmeans.n_iter_

kmeans.labels_

# ELbow graph to determine ideal number of clusters

SSE = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters = k, init = 'k-means++')
    kmeans.fit(scaled_df2)
    SSE.append(kmeans.inertia_)

plt.plot(range(1, 11), SSE)
plt.xlabel("Number of Clusters")
plt.ylabel("SSE")
plt.show()

"""The elbow is at 2; thus, the ideal number of clusters is 2."""

# determining the silhouette coefficient

kmeans = KMeans(n_clusters = 2, init = 'k-means++')
kmeans.fit(scaled_df2)
pred = kmeans.predict(scaled_df2)

print("Silhouette coefficient with 2 clusters: ", silhouette_score(scaled_df2, pred))

"""**How will you incorporate the streaming data into your already existing clusters?**

To incorporate streaming data, we use _'minibatch K Means'_. The new data points are assigned to the apt cluster. Then the centroids and number of points are updated using exponential moving average as follows:

$$
c_{t + 1} = \frac{c_{t}n_{t}\alpha + x_{t}m_{t}}{n_{t} + m_{t}}
\\
n_{t + 1} = n_{t} + m_{t}
$$

where

$$
c_{t} = Current\space centroid
\\
c_{t + 1} = Updated\space centroid
\\
n_{t} = Number\space of\space data\space points\space belonging\space to\space cluster
\\
n_{t + 1} = Updated\space number\space of\space data\space points\space belonging\space to\space cluster
\\
x_{t} = Centroid\space of\space new\space data\space points
\\
m_{t} = Number\space of\space new\space data\space points
\\
\alpha = Constant\space between\space 0\space and\space 1.\space If\space this\space is\space 1,\space the\space past\space data\space is\space weighed\space as\space much\space as\space the\space new,\space arriving\space data.\space If\space it\space is\space 0,\space then\space the\space past\space data\space is\space not\space weighed\space at\space all!
$$
"""